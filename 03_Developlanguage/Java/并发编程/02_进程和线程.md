---
Title: Java 并发编程-进程和线程
Category: Java
tags:
  - java
  - 并发编程
---
## 进程和线程  
  进程，是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。
  线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。  

## 进程  
  
最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在思考或者输入时，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。  
  
### 批处理操作系统  
  
后来有了**批处理操作系统**，把一系列需要操作的指令写下来，形成一个清单，一次性交给计算机。用户将多个需要执行的程序写在磁带上，然后交由计算机去读取并逐个执行这些程序，并将输出结果写在另一个磁带上。  
  
批处理操作系统在一定程度上提高了计算机的效率，但是由于**批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行**，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于 I/O 操作、网络等原因阻塞，所以**批处理操作效率也不高**。  
  
### 进程的提出  
  
人们对于计算机的性能要求越来越高，现有的批处理操作系统并不能满足人们的需求，而批处理操作系统的瓶颈在于内存中只存在一个程序，那么内存中能不能存在多个程序呢？这是人们亟待解决的问题。  
  
于是，科学家们提出了进程的概念。  
  
进程就是**应用程序在内存中分配的空间，也就是正在运行的程序**，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。  
  
> 程序：用某种编程语言(Java、Python 等)编写，能够完成一定任务或者功能的代码集合，是指令和数据的有序集合，是**一段静态代码**。  
  
此时，CPU 采用时间片轮转的方式运行进程：CPU 为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且 CPU 分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换，不用等待时间片用完。  
  
> 当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。  
  
使用进程+CPU 时间片轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务，换句话说，**进程让操作系统的并发成为了可能**。虽然并发从宏观上看有多个任务在执行，但在事实上，对于**单核 CPU**来说，任意具体时刻都只有一个任务在占用 CPU 资源。  
  
### 对操作系统的要求进一步提高  
  
虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，人们并不满足一个进程在一段时间只能做一件事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。  
  
> 比如杀毒软件在检测用户电脑时，如果在某一项检测中卡住了，那么后面的检测项也会受到影响。或者说当你使用杀毒软件中的扫描病毒功能时，在扫描病毒结束之前，无法使用杀毒软件中清理垃圾的功能，这显然无法满足人们的要求。  
  
## 线程  
  
那么能不能让这些子任务同时执行呢？于是人们又提出了线程的概念，**让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。**  
  
> - 使用线程之后，事情就变得简单多了。当用户使用扫描病毒功能时，就让扫描病毒这个线程去执行。同时，如果用户又使用清理垃圾功能，那么可以先暂停扫描病毒线程，先响应用户的清理垃圾的操作，让清理垃圾这个线程去执行。响应完后再切换回来，接着执行扫描病毒线程。  
> - 注意：操作系统是如何分配时间片给每一个线程的，涉及到线程的调度策略，有兴趣的同学可以看一下《操作系统》相关的内容，这里就不再展开了，涉及的内容比较多。  
  
总之，进程和线程的提出极大的提高了操作系统的性能。**进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。**  
  
**既然多进程的方式可以实现并发，为什么还要使用多线程呢？**  
  
多进程方式确实可以实现并发，但使用多线程，有以下几个好处：  
  
- 进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信很容易。  
- 进程是重量级的，而线程是轻量级的，多线程方式的系统开销更小。  
  
## 进程和线程的区别  
  
进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是**是否单独占有内存地址空间及其它系统资源（比如 I/O）**：  
  
- 进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。  
- 进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。  
- 进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。  
  
另外一个重要区别是，**进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位**，即 CPU 分配时间的单位 。  

计算机的核心是 CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。    
  
假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。    
  
进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。    
  
一个车间里，可以有很多工人。他们协同完成一个任务。    
  
线程就好比车间里的工人。一个进程可以包括多个线程。    
  
车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。    
  
可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。    
  
一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。    
  
还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于 n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。    
  
这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。  
  
不难看出，mutex 是 semaphore 的一种特殊情况（n=1 时）。也就是说，完全可以用后者替代前者。但是，因为 mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。    
  
操作系统的设计，因此可以归结为三点：  
  
- 以多进程形式，允许多个任务同时运行；  
- 以多线程形式，允许单个任务分成不同的部分运行；  
- 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。  
  
## 线程带来的好处  
  
比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以利用多线程的技术来完成。**面对复杂业务模型，并行程序会比串行程序更适用于业务需求** 。正是因为这些优点，使得多线程技术得到了进一步的重视，Java 开发者也应该掌握并发编程，以便：  
  
- 充分利用多核 CPU 的计算能力；  
- 方便进行业务拆分，提升应用性能  
  
## 小结  
  
总结来说，进程和线程都是操作系统用于并发执行的方式，但是它们在资源管理、独立性、开销以及影响范围等方面有所不同。  
  
- 进程是操作系统分配资源的基本单位，线程是操作系统调度的基本单位。  
- 进程拥有独立的内存空间，线程共享所属进程的内存空间。  
- 进程的创建和销毁需要资源的分配和回收，开销较大；线程的创建和销毁只需要保存寄存器和栈信息，开销较小。  
- 进程间的通信比较复杂，而线程间的通信比较简单。  
- 进程间是相互独立的，一个进程崩溃不会影响其他进程；线程间是相互依赖的，一个线程崩溃可能影响整个程序的稳定性。  
  
---

## 创建线程的三种方式  

### 继承 Thread 类  
  
①：创建一个类继承 Thread 类，并重写 run 方法。  
  
```java  
public class MyThread extends Thread {
  public void run() {
    System.out.println("MyThread running");
  }
}
```  
  
我们来写个测试方法验证下：  
  
```java  
//创建MyThread对象  
MyThread t1=new  MyThread();  
MyThread t2=new  MyThread();  
MyThread t3=new  MyThread();  
//设置线程的名字  
t1.setName("鲁班");  
t2.setName("刘备");  
t3.setName("亚瑟");  
//启动线程  
t1.start();  
t2.start();  
t3.start();  
```  
  
来看一下执行后的结果：  
  
#todo  
  
### 实现 Runnable 接口  
  
②：创建一个类实现 Runnable 接口，并重写 run 方法。  
  
```java  
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            try {//sleep会发生异常要显示处理
                Thread.sleep(20);//暂停20毫秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "打了:" + i + "个小兵");
        }
    }
}
```  
  
我们来写个测试方法验证下：  
  
```java  
//创建MyRunnable类  
MyRunnable mr = new MyRunnable();  
//创建Thread类的有参构造,并设置线程名  
Thread t1 = new Thread(mr, "张飞");  
Thread t2 = new Thread(mr, "貂蝉");  
Thread t3 = new Thread(mr, "吕布");  
//启动线程  
t1.start();  
t2.start();  
t3.start();  
```  
  
来看一下执行后的结果：  
  
#todo  
  
### 实现 Callable 接口  
  
③：实现 Callable 接口，重写 call 方法，这种方式可以通过 FutureTask 获取任务执行的返回值。  
  
```java  
public class CallerTask implements Callable<String> {
    public String call() throws Exception {
        return "Hello,i am running!";
    }

    public static void main(String[] args) {
        //创建异步任务
        FutureTask<String> task=new FutureTask<String>(new CallerTask());
        //启动线程
        new Thread(task).start();
        try {
            //等待执行完成，并获取返回结果
            String result=task.get();
            System.out.println(result);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```  

#### 异步计算结果 Future 接口  
  
在前面的例子中，我们通过 Future 来获取 Callable 任务的执行结果，那么 Future 是什么呢？  
  
Future 位于 `java.util.concurrent` 包下，它是一个接口：  
  
```java  
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
} 
```  
  
一共声明了 5 个方法：  
  
- `cancel()` 方法用来取消任务，如果取消任务成功则返回 true，如果取消任务失败则返回 false。参数 mayInterruptIfRunning 表示是否允许取消正在执行却没有执行完毕的任务，如果设置 true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论 mayInterruptIfRunning 为 true 还是 false，此方法肯定返回 false，即如果取消已经完成的任务会返回 false；如果任务正在执行，若 mayInterruptIfRunning 设置为 true，则返回 true，若 mayInterruptIfRunning 设置为 false，则返回 false；如果任务还没有执行，则无论 mayInterruptIfRunning 为 true 还是 false，肯定返回 true。  
- `isCancelled()` 方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。  
- `isDone()` 方法表示任务是否已经完成，若任务完成，则返回 true；  
- `get()`方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；  
- `get(long timeout, TimeUnit unit)`用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回 null。  
  
也就是说 Future 提供了三种功能：  
  
- 1）判断任务是否完成；  
- 2）能够中断任务；  
- 3）能够获取任务执行结果。  
  
由于 Future 只是一个接口，如果直接 new 的话，编译器是会有一个 ⚠️ 警告的，它会提醒我们最好使用 FutureTask。    
  
实际上，FutureTask 是 Future 接口的一个唯一实现类，我们在下面的例子中 `executorService.submit()` 返回的就是 FutureTask，通过 debug 模式可以观察到。    
  
#### 异步计算结果 FutureTask 实现类  
  
我们来看一下 FutureTask 的实现：  
  
```java  
public class FutureTask<V> implements RunnableFuture<V>  
```  
  
FutureTask 类实现了 RunnableFuture 接口，我们看一下 RunnableFuture 接口的实现：  
  
```java  
public interface RunnableFuture<V> extends Runnable, Future<V> {  
    void run();}  
```  
  
可以看出 RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。  
  
FutureTask 提供了 2 个构造器：  
  
```java  
public FutureTask(Callable<V> callable) {  
}  
public FutureTask(Runnable runnable, V result) {  
}  
```  
  
当需要异步执行一个计算并在稍后的某个时间点获取其结果时，就可以使用 FutureTask。来个例子  
  
```java  
// 创建一个固定大小的线程池
ExecutorService executorService = Executors.newFixedThreadPool(3);

// 创建一系列 Callable
Callable<Integer>[] tasks = new Callable[5];
for (int i = 0; i < tasks.length; i++) {
    final int index = i;
    tasks[i] = new Callable<Integer>() {
        @Override
        public Integer call() throws Exception {
            TimeUnit.SECONDS.sleep(index + 1);
            return (index + 1) * 100;
        }
    };
}

// 将 Callable 包装为 FutureTask，并提交到线程池
FutureTask<Integer>[] futureTasks = new FutureTask[tasks.length];
for (int i = 0; i < tasks.length; i++) {
    futureTasks[i] = new FutureTask<>(tasks[i]);
    executorService.submit(futureTasks[i]);
}

// 获取任务结果
for (int i = 0; i < futureTasks.length; i++) {
    System.out.println("Result of task" + (i + 1) + ": " + futureTasks[i].get());
}

// 关闭线程池
executorService.shutdown();
```  
  
来看一下输出结果  
  
```  
Result of task1: 100  
Result of task2: 200  
Result of task3: 300  
Result of task4: 400  
Result of task5: 500  
```

## 关于线程的一些疑问  
  
### 1、为什么要重写 run 方法？  
  
这是因为默认的`run()`方法不会做任何事情。  
  
为了让线程执行一些实际的任务，我们需要提供自己的`run()`方法实现，这就需要重写`run()`方法。  
  
```java  
public class MyThread extends Thread {
  public void run() {
    System.out.println("MyThread running");
  }
}
```  
  
在这个例子中，我们重写了`run()`方法，使其打印出一条消息。当我们创建并启动这个线程的实例时，它就会打印出这条消息。  
  
### 2、run 方法和 start 方法有什么区别？  
  
- `run()`：封装线程执行的代码，直接调用相当于调用普通方法。  
- `start()`：启动线程，然后由 JVM 调用此线程的 `run()` 方法。  
  
**3、通过继承 Thread 的方法和实现 Runnable 接口的方式创建多线程，哪个好？**  
  
实现 Runable 接口好，原因有两个：  
  
- ①、避免了 Java 单继承的局限性，Java 不支持多重继承，因此如果我们的类已经继承了另一个类，就不能再继承 Thread 类了。  
- ②、适合多个相同的程序代码去处理同一资源的情况，把线程、代码和数据有效的分离，更符合面向对象的设计思想。Callable 接口与 Runnable 非常相似，但可以返回一个结果。 
  
## 控制线程的其他方法  
  
针对线程控制，大家还会遇到 3 个常见的方法，我们来一一介绍下。  
  
### 1）sleep()  
  
使当前正在执行的线程暂停指定的毫秒数，也就是进入休眠的状态。  
  
需要注意的是，sleep 的时候要对异常进行处理。  
  
```java  
try {//sleep会发生异常要显示处理  
    Thread.sleep(20);//暂停20毫秒  
} catch (InterruptedException e) {  
    e.printStackTrace();}  
```  
  
### 2）join()  
  
等待这个线程执行完才会轮到后续线程得到 cpu 的执行权，使用这个也要捕获异常。  
  
```java  
//创建MyRunnable类  
MyRunnable mr = new MyRunnable();  
//创建Thread类的有参构造,并设置线程名  
Thread t1 = new Thread(mr, "张飞");  
Thread t2 = new Thread(mr, "貂蝉");  
Thread t3 = new Thread(mr, "吕布");  
//启动线程  
t1.start();  
try {  
    t1.join(); //等待t1执行完才会轮到t2，t3抢  
} catch (InterruptedException e) {  
    e.printStackTrace();}  
t2.start();  
t3.start();  
```  
  
来看一下执行后的结果：  
  
#todo  
  
### 3）setDaemon()  
  
将此线程标记为守护线程，准确来说，就是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。  
  
```java  
//创建MyRunnable类  
MyRunnable mr = new MyRunnable();  
//创建Thread类的有参构造,并设置线程名  
Thread t1 = new Thread(mr, "张飞");  
Thread t2 = new Thread(mr, "貂蝉");  
Thread t3 = new Thread(mr, "吕布");  
  
t1.setDaemon(true);  
t2.setDaemon(true);  
  
//启动线程  
t1.start();  
t2.start();  
t3.start();  
```  
  
如果其他线程都执行完毕，main 方法（主线程）也执行完毕，JVM 就会退出，也就是停止运行。如果 JVM 都停止运行了，守护线程自然也就停止了。  
  
### 4）yield()  
  
yield() 方法是一个静态方法，用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。然而，它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和 JVM 的线程调度策略。  
  
```java  
class YieldExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(YieldExample::printNumbers, "刘备");
        Thread thread2 = new Thread(YieldExample::printNumbers, "关羽");

        thread1.start();
        thread2.start();
    }

    private static void printNumbers() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);

            // 当 i 是偶数时，当前线程暂停执行
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + " 让出控制权...");
                Thread.yield();
            }
        }
    }
}
```  
  
运行结果：  
  
#todo  
  
从这个结果可以看得出来，即便有时候让出了控制权，其他线程也不一定会执行。  
  
  
## 线程的状态 
  
线程的生命周期。
  
![[09_Attachments/Java/并发编程/Java_Thread_001.png]]  
  
我们先来看看操作系统中的线程状态转换。在操作系统中，线程被视为轻量级的进程，所以**线程状态其实和进程状态是一致的**。  
  
![[09_Attachments/Java/并发编程/Java_Thread_002.png]]  
  
操作系统的线程主要有以下三个状态：  
  
- 就绪状态(ready)：线程正在等待使用 CPU，经调度程序调用之后进入 running 状态。  
- 执行状态(running)：线程正在使用 CPU。  
- 等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如 I/O）。  
  
然后我们来看 Java 线程的 6 个状态：  
  
```java  
// Thread.State 源码
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
} 
```  
  
## NEW  
  
处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的`start()`方法。  
  
```java  
private void testStateNew() {
    Thread thread = new Thread(() -> {});
    System.out.println(thread.getState()); // 输出 NEW
}
```  
  
从上面可以看出，只是创建了线程而并没有调用 start 方法，此时线程处于 NEW 状态。  
  
### 关于 start 的两个引申问题  
  
1. 反复调用同一个线程的 start 方法是否可行？  
2. 假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可行？  
  
要分析这两个问题，我们先来看看`start()`的源码：  
  
```java  
// 使用synchronized关键字保证这个方法是线程安全的
public synchronized void start() {
    // threadStatus != 0 表示这个线程已经被启动过或已经结束了
    // 如果试图再次启动这个线程，就会抛出IllegalThreadStateException异常
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    // 将这个线程添加到当前线程的线程组中
    group.add(this);

    // 声明一个变量，用于记录线程是否启动成功
    boolean started = false;
    try {
        // 使用native方法启动这个线程
        start0();
        // 如果没有抛出异常，那么started被设为true，表示线程启动成功
        started = true;
    } finally {
        // 在finally语句块中，无论try语句块中的代码是否抛出异常，都会执行
        try {
            // 如果线程没有启动成功，就从线程组中移除这个线程
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            // 如果在移除线程的过程中发生了异常，我们选择忽略这个异常
        }
    }
}
```  
  
可以看到，在`start()`内部，有一个 threadStatus 变量。如果它不等于 0，调用`start()`会直接抛出异常。  
  
接着往下看，有一个 native 的 `start0()` 方法。这个方法并没有对**threadStatus**进行处理。到这里我们仿佛拿这个 threadStatus 没辙了，通过 debug 再看一下:  
  
```java  
@Test  
public void testStartMethod() {  
    Thread thread = new Thread(() -> {});  
    thread.start(); // 第一次调用  
    thread.start(); // 第二次调用  
}  
```  
  
在 start 方法内部的最开始打断点：  
  
- 第一次调用时 threadStatus 的值是 0。  
- 第二次调用时 threadStatus 的值不为 0。  
  
查看当前线程状态的源码：  
  
```java  
// Thread.getState方法源码：
public State getState() {
    // get current thread state
    return sun.misc.VM.toThreadState(threadStatus);
}

// sun.misc.VM 源码：
// 如果线程的状态值和4做位与操作结果不为0，线程处于RUNNABLE状态。
// 如果线程的状态值和1024做位与操作结果不为0，线程处于BLOCKED状态。
// 如果线程的状态值和16做位与操作结果不为0，线程处于WAITING状态。
// 如果线程的状态值和32做位与操作结果不为0，线程处于TIMED_WAITING状态。
// 如果线程的状态值和2做位与操作结果不为0，线程处于TERMINATED状态。
// 最后，如果线程的状态值和1做位与操作结果为0，线程处于NEW状态，否则线程处于RUNNABLE状态。
public static State toThreadState(int var0) {
    if ((var0 & 4) != 0) {
        return State.RUNNABLE;
    } else if ((var0 & 1024) != 0) {
        return State.BLOCKED;
    } else if ((var0 & 16) != 0) {
        return State.WAITING;
    } else if ((var0 & 32) != 0) {
        return State.TIMED_WAITING;
    } else if ((var0 & 2) != 0) {
        return State.TERMINATED;
    } else {
        return (var0 & 1) == 0 ? State.NEW : State.RUNNABLE;
    }
}
```  
  
还记得我们引申的两个问题吗？  
  
1. 反复调用同一个线程的 start 方法是否可行？  
2. 假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可行？  
  
结合上面的源码可以得到的答案是：  
  
1. 都不行，在调用 start 之后，threadStatus 的值会改变（`threadStatus !=0`），再次调用 start 方法会抛出 IllegalThreadStateException 异常。  
2. threadStatus 为 2 代表当前线程状态为 TERMINATED（下面会讲）。  
  
## RUNNABLE  
  
表示当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。  
  
我们来看看 Thread 源码里对 RUNNABLE 状态的定义：  
  
```java  
/**
 * Thread state for a runnable thread.  A thread in the runnable
 * state is executing in the Java virtual machine but it may
 * be waiting for other resources from the operating system
 * such as processor.
 */
```  
  
意思大家应该都能看得懂，不懂翻译一下（其实前面已经翻译过了）。  
  
也就是说，Java 线程的**RUNNABLE**状态其实包括了操作系统线程的**ready**和**running**两个状态。  
  
## BLOCKED  
  
阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。  
  
我们用 BLOCKED 状态举个生活中的例子：  
  
假如今天你下班后准备去食堂吃饭。你来到食堂仅有的一个窗口，发现前面已经有个人在窗口前了，此时你必须得等前面的人从窗口离开才行。  
  
假设你是线程 t2，你前面的那个人是线程 t1。此时 t1 占有了锁（食堂唯一的窗口），t2 正在等待锁的释放，所以此时 t2 就处于 BLOCKED 状态。  
  
## WAITING  
  
等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。  
  
调用下面这 3 个方法会使线程进入等待状态：  
  
- `Object.wait()`：使当前线程处于等待状态直到另一个线程唤醒它；  
- `Thread.join()`：等待线程执行完毕，底层调用的是 Object 的 wait 方法；  
- `LockSupport.park()`：除非获得调用许可，否则禁用当前线程进行线程调度。LockSupport 我们在后面会细讲。  
  
我们延续上面的例子继续解释一下 WAITING 状态：  
  
你等了好几分钟，终于轮到你了，突然你们有一个“不懂事”的经理来了。你看到他你就有一种不祥的预感，果然，他是来找你的。  
  
他把你拉到一旁叫你待会儿再吃饭，说他下午要去作报告，赶紧来找你了解一下项目的情况。你心里虽然有一万个不愿意但是你还是从食堂窗口走开了。  
  
此时，假设你还是线程 t2，你的经理是线程 t1。虽然你此时都占有锁（窗口）了，“不速之客”来了你还是得释放掉锁。此时你 t2 的状态就是 WAITING。然后经理 t1 获得锁，进入 RUNNABLE 状态。  
  
要是经理 t1 不主动唤醒你 t2（notify、notifyAll..），可以说你 t2 只能一直等待了。  
  
## TIMED_WAITING  
  
超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。  
  
调用如下方法会使线程进入超时等待状态：  
  
- `Thread.sleep(long millis)`：使当前线程睡眠指定时间；  
- `Object.wait(long timeout)`：线程休眠指定时间，等待期间可以通过`notify()`/`notifyAll()`唤醒；  
- `Thread.join(long millis)`：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；  
- `LockSupport.parkNanos(long nanos)`： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；LockSupport我们在后面会细讲；  
- `LockSupport.parkUntil(long deadline)`：同上，也是禁止线程进行调度指定时间；  
  
我们继续延续上面的例子来解释一下 TIMED_WAITING 状态：  
  
到了第二天中午，又到了饭点，你还是到了窗口前。  
  
突然间想起你的同事叫你等他一起，他说让你等他十分钟他改个 bug。  
  
好吧，那就等等吧，你就离开了窗口。很快十分钟过去了，你见他还没来，你想都等了这么久了还不来，那你还是先去吃饭好了。  
  
这时你还是线程 t1，你改 bug 的同事是线程 t2。t2 让 t1 等待了指定时间，此时 t1 等待期间就属于 TIMED_WATING 状态。  
  
t1 等待 10 分钟后，就自动唤醒，拥有了去争夺锁的资格。  
  
## TERMINATED  
  
终止状态。此时线程已执行完毕。  
  
## 线程状态的转换  
  
根据上面关于线程状态的介绍我们可以得到下面的**线程状态转换图**：  
  
![](09_Attachments/Java/并发编程/Java_Thread_003.png)
  
### BLOCKED 与 RUNNABLE 状态的转换  
  
我们在上面说过：处于 BLOCKED 状态的线程在等待锁的释放。假如这里有两个线程 a 和 b，a 线程提前获得了锁并暂未释放锁，此时 b 就处于 BLOCKED 状态。我们来看一个例子：  
  
```java  
@Test  
public void blockedTest() {  
    Thread a = new Thread(new Runnable() {  
        @Override  
        public void run() {  
            testMethod();  
        }  
    }, "a");  
  
    Thread b = new Thread(new Runnable() {  
        @Override  
        public void run() {  
            testMethod();  
        }  
    }, "b");  
  
    a.start();  
    b.start();  
  
    System.out.println(a.getName() + ":" + a.getState()); // 输出？  
    System.out.println(b.getName() + ":" + b.getState()); // 输出？  
}  
  
// 同步方法争夺锁  
private synchronized void testMethod() {  
    try {  
        Thread.sleep(2000L);  
    } catch (InterruptedException e) {  
        e.printStackTrace();  
    }  
}  
```  
  
初看之下，大家可能会觉得线程 a 会先调用同步方法，同步方法内又调用了`Thread.sleep()`方法，必然会输出 TIMED_WAITING，而线程 b 因为等待线程 a 释放锁所以必然会输出 BLOCKED。  
  
其实不然，有两点需要值得大家注意：  
  
- 一是**在测试方法`blockedTest()`内还有一个 main 线程**  
- 二是**启动线程后执行 run 方法还是需要消耗一定时间的**。  
  
测试方法的 main 线程只保证了 a，b 两个线程调用 start 方法（转化为 RUNNABLE 状态），如果 CPU 执行效率高一点，还没等两个线程真正开始争夺锁，就已经打印此时两个线程的状态（RUNNABLE）了。  
  
当然，如果 CPU 执行效率低一点，其中某个线程也是可能打印出 BLOCKED 状态的（此时两个线程已经开始争夺锁了）。  

#todo 
  
这时你可能又会问了，要是我想要打印出 BLOCKED 状态我该怎么处理呢？  
  
BLOCKED 状态的产生需要两个线程争夺锁才行。那我们处理下测试方法里的 main 线程就可以了，让它“休息一会儿”，调用一下`Thread.sleep()`方法。  
  
这里需要注意的是 main 线程休息的时间，要保证在线程争夺锁的时间内，不要等到前一个线程锁都释放了你再去争夺锁，此时还是得不到 BLOCKED 状态的。  
  
我们把上面的测试方法 blockedTest 改动一下：  
  
```java  
public void blockedTest() throws InterruptedException {
    ······
    a.start();
    Thread.sleep(1000L); // 需要注意这里main线程休眠了1000毫秒，而testMethod()里休眠了2000毫秒
    b.start();
    System.out.println(a.getName() + ":" + a.getState()); // 输出？
    System.out.println(b.getName() + ":" + b.getState()); // 输出？
}  
```  
  
运行结果如下所示：  
  
#todo  
  
在这个例子中两个线程的状态转换如下  
  
- a 的状态转换过程：RUNNABLE（`a.start()`） -> TIMED_WATING（`Thread.sleep()`）->RUNABLE（`sleep()`时间到）->_BLOCKED(未抢到锁)_ -> TERMINATED  
- b 的状态转换过程：RUNNABLE（`b.start()`) -> _BLOCKED(未抢到锁)_ ->TERMINATED  
  
斜体表示可能出现的状态， 大家可以在自己的电脑上多试几次看看输出。同样，这里的输出也可能有多钟结果。  
  
### WAITING 状态与 RUNNABLE 状态的转换  
  
根据转换图我们知道有 3 个方法可以使线程从 RUNNABLE 状态转为 WAITING 状态。我们主要介绍下**Object.wait()**和**Thread.join()**。  
  
#### Object.wait()  
  
调用`wait()`方法前线程必须持有对象的锁。  
  
线程调用`wait()`方法时，会释放当前的锁，直到有其他线程调用`notify()`/`notifyAll()`方法唤醒等待锁的线程。  
  
需要注意的是，其他线程调用`notify()`方法只会唤醒单个等待锁的线程，如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用`wait()`方法的线程。  
  
同样，调用`notifyAll()`方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。  
  
#### Thread.join()  
  
调用`join()`方法，会一直等待这个线程执行完毕（转换为 TERMINATED 状态）。  
  
我们再把上面的例子线程启动那里改变一下：  
  
```java  
public void blockedTest() {
    ······
    a.start();
    a.join();
    b.start();
    System.out.println(a.getName() + ":" + a.getState()); // 输出 TERMINATED
    System.out.println(b.getName() + ":" + b.getState());
}
```  
  
要是没有调用 join 方法，main 线程不管 a 线程是否执行完毕都会继续往下走。  
  
a 线程启动之后马上调用了 join 方法，这里 main 线程就会等到 a 线程执行完毕，所以这里 a 线程打印的状态固定是**TERMINATED**。  
  
至于 b 线程的状态，有可能打印 RUNNABLE（尚未进入同步方法），也有可能打印 TIMED_WAITING（进入了同步方法）。  
  
### TIMED_WAITING 与 RUNNABLE 状态转换  
  
TIMED_WAITING 与 WAITING 状态类似，只是 TIMED_WAITING 状态等待的时间是指定的。  
  
#### Thread.sleep(long)  
  
使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入 RUNNABLE 状态。  
  
#### Object.wait(long)  
  
`wait(long)`方法使线程进入 TIMED_WAITING 状态。这里的`wait(long)`方法与无参方法 wait()相同的地方是，都可以通过其他线程调用`notify()`或`notifyAll()`方法来唤醒。  
  
不同的地方是，有参方法`wait(long)`就算其他线程不来唤醒它，经过指定时间 long 之后它会自动唤醒，拥有去争夺锁的资格。  
  
#### Thread.join(long)  
  
`join(long)`使当前线程执行指定时间，并且使线程进入 TIMED_WAITING 状态。  
  
我们再来改一改刚才的示例:  
  
```java  
public void blockedTest() {
    ······
    a.start();
    a.join(1000L);
    b.start();
    System.out.println(a.getName() + ":" + a.getState()); // 输出 TIEMD_WAITING
    System.out.println(b.getName() + ":" + b.getState());
}
```  
  
这里调用`a.join(1000L)`，因为是指定了具体 a 线程执行的时间的，并且执行时间是小于 a 线程 sleep 的时间，所以 a 线程状态输出 TIMED_WAITING。  
  
b 线程状态仍然不固定（RUNNABLE 或 BLOCKED）。  
  
### 线程中断  
  
在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在 Java 里还没有安全方法来直接停止线程，但是 Java 提供了线程中断机制来处理需要中断线程的情况。  
  
线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。  
  
简单介绍下 Thread 类里提供的关于线程中断的几个方法：  
  
- `Thread.interrupt()`：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为 true（默认是 flase）；  
- `Thread.isInterrupted()`：测试当前线程是否被中断。  
- `Thread.interrupted()`：检测当前线程是否被中断，与 `isInterrupted()` 方法不同的是，这个方法如果发现当前线程被中断，会清除线程的中断状态。  
  
在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的时机中断请求，也可以完全不处理继续执行下去。  

## 线程安全问题
有时候我们会发现，明明在单线程环境中正常运行的代码，在多线程环境中就会出现意料之外的结果，这就是大家常说的『线程不安全』。那到底什么是线程不安全呢？  
  
### 原子性  
  
举一个银行转账的例子，比如从账户 A 向账户 B 转 1000 元，那么必然包括 2 个操作：从账户 A 减去 1000 元，往账户 B 加上 1000 元，两个操作都成功才意味着一次转账最终成功。    
  
试想一下，如果这两个操作不具备原子性，从 A 的账户扣减了 1000 元之后，操作突然终止了，账户 B 没有增加 1000 元，那问题就大了。    
  
银行转账有两个步骤，出现意外后导致转账失败，说明没有原子性。  
  
> - 原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。  
> - 原子操作：即不会被线程调度机制打断的操作，没有上下文切换。  
  
在并发编程中很多操作都不是原子操作，出个小题目：  
  
```java  
int i = 0; // 操作1  
i++;   // 操作2  
int j = i; // 操作3  
i = i + 1; // 操作4  
```  
  
上面这四个操作中哪些是原子操作，哪些不是呢？  
  
有些小伙伴可能认为这些都是原子操作，其实只有操作 1和3 是原子操作。  
  
- 操作 1：这是原子操作，因为它是一个单一的、不可分割的步骤。  
- 操作 2：这不是原子操作。这实际上是一个 "read-modify-write" 操作，它包括了读取 i 的值，增加 i，然后写回 i。  
- 操作 3：这是原子操作，因为它是一个单一的、不可分割的步骤。  
- 操作 4：这不是原子操作。和 i++ 一样，这也是一个 "read-modify-write" 操作。  
  
在单线程环境下上述四个操作都不会出现问题，但是在多线程环境下，如果不加锁的话，可能会得到意料之外的值。我们来测试一下，看看输出结果。  
  
```java  
public class YuanziDeo {
    private static int i = 0;

    public static void main(String[] args) throws InterruptedException {
        int numThreads = 2;
        int numIncrementsPerThread = 100000;

        Thread[] threads = new Thread[numThreads];

        for (int j = 0; j < numThreads; j++) {
            threads[j] = new Thread(() -> {
                for (int k = 0; k < numIncrementsPerThread; k++) {
                    i++;
                }
            });
            threads[j].start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        System.out.println("Final value of i = " + i);
        System.out.println("Expected value = " + (numThreads * numIncrementsPerThread));
    }
} 
```  
  
输出如下：  
  
```  
Final value of i = 102249  
Expected value = 200000  
```  
  
i 期望的值为 200000，但实际跑出来的是 102249，这证明 i++ 不是一个原子操作，对吧？  
  
### 可见性  
  
talk is cheap，show me code，来看这段代码：  
  
```java  
class Test {  
  int i = 50;  int j = 0;  
  public void update() {    // 线程1执行  
    i = 100;  }  
  public int get() {    // 线程2执行  
    j = i;    return j;  }}  
```  
  
假如有两个线程，线程 1 执行 update 方法将 i 赋值为 100，一般情况下线程 1 会在自己的工作内存中完成赋值操作，但不会及时将新值刷新到主内存中。  
  
这个时候线程 2 执行 get 方法，首先会从主内存中读取 i 的值，然后加载到自己的工作内存中，此时读到 i 的值仍然是 50，再将 50 赋值给 j，最后返回 j 的值就是 50 了。原本期望返回 100，结果返回 50，这就是可见性问题，线程 1 对变量 i 进行了修改，线程 2 并没有立即看到 i 的新值。  
  
> 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。    
  
每个线程都有属于自己的工作内存，工作内存和主内存间需要通过 store 和 load 等进行交互。  
  
为了解决多线程的可见性问题，Java 提供了`volatile`这个关键字。当一个共享变量被 volatile 修饰时，它会保证修改的值立即更新到主存当中，这样的话，当有其他线程需要读取时，就会从内存中读到新值。普通的共享变量不能保证可见性，因为变量被修改后什么时候刷回到主存是不确定的，因此另外一个线程读到的可能就是旧值。  
  
当然 Java 的锁机制如 synchronized 和 lock 也是可以保证可见性的。  
  
### 活跃性问题  
  
上面讲到为了解决`可见性`的问题，我们可以采取加锁的方式来解决，但如果加锁使用不当也容易引入其他问题，比如『死锁』。  
  
在讲『死锁』之前，我们需要先引入另外一个概念：`活跃性问题`。  
  
> 活跃性是指某件正确的事情最终会发生，但当某个操作无法继续下去的时候，就会发生活跃性问题。  
  
概念可能有点拗口，活跃性问题一般有这样几类：`死锁`，`活锁`，`饥饿问题`。  
  
#### 死锁  
  
死锁是指多个线程因为环形等待锁的关系而永远地阻塞下去。    
  
#### 活锁  
  
死锁是两个线程都在等待对方释放锁导致阻塞。而`活锁`的意思是线程没有阻塞，还活着呢。当多个线程都在运行并且都在修改各自的状态，而其他线程又依赖这个状态，就导致任何一个线程都无法继续执行，只能重复着自身的动作，于是就发生了活锁。    
  
举一个生活中的例子，大家平时在走路的时候，迎面走来一个人，两个人互相让路，但是又同时走到了一个方向，如果一直这样重复着避让，这俩人就发生了活锁，学到了吧，嘿嘿。  
  
#### 饥饿  
  
如果一个线程无其他异常却迟迟不能继续运行，那基本上是处于饥饿状态了。  
  
常见的有几种场景:  
  
- 高优先级的线程一直在运行消耗 CPU，所有的低优先级线程一直处于等待；  
- 一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问；  
  
有一个非常经典的饥饿问题就是`哲学家用餐问题`，如下图所示，有五个哲学家在用餐，每个人必须要同时拿两把叉子才开始就餐，如果哲学家 1 和哲学家 3 同时开始就餐，那哲学家 2、4、5 就得饿肚子等待了。    
  
## 性能问题  
  
前面讲到了线程安全和死锁、活锁这些问题，如果这些都没有发生，多线程并发一定比单线程串行执行快吗？答案是不一定，因为多线程有`创建线程`和`线程上下文切换`的开销。  
  
创建线程是直接向系统申请资源的，对操作系统来说，创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度等。  
  
线程创建完之后，还会遇到线程`上下文切换`。    
  
CPU 是很宝贵的资源，速度非常快，为了保证雨露均沾，通常会给不同的线程分配`时间片`，当 CPU 从执行一个线程切换到执行另一个线程时，CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行线程的本地数据，程序指针等，也就是『上下文切换』。  
  
一般减少上下文切换的方法有：  
  
- 无锁并发编程：可以参照 ConcurrentHashMap 锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。  
- CAS 算法，利用 Atomic+ CAS 算法来更新数据，采用乐观锁的方式，可以有效减少一部分不必要的锁竞争带来的上下文切换。  
- 使用最少线程：避免创建不必要的线程，如果任务很少，但创建了很多的线程，这样就会造成大量的线程都处于等待状态。  
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。  
  
## 小结  
  
多线程用好了可以让程序的效率成倍提升，用不好可能比单线程还要慢。
