---
Title: Java 基础核心要点-基本数据类型缓存池
Category: Java
tags:
  - java
  - 基本数据类型
  - 缓存池
---
## Integer 缓存池

这里引申出一个经典问题，看下面代码

```java
Integer a = 100;

Integer b = 100;
System.out.println(a == b);//true

Integer c = 200;
Integer d = 200;
System.out.println(c == d);//false
```

为什么第一个输出的是 true，第二个输出的是 false？

Integer a = 100 的这种直接赋值操作，是调⽤Integer.ValueOf (100) 方法，从 Integer.ValueOf () 源码可以看到，返回的是 Integer 对象，但这里的实现并不是简单的 new Integer，而是先判断 i 这个值是否在 IntegerCache 范围内，如果在，直接返回 IntegerCache 中的值，如果不在则 new Integer

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

 private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {}
}
```

从源码可以看到，默认 Integer cache 的下限是-128，上限默认 127。当赋值 100 给 Integer 时，刚好在这个范围内，所以从 cache 中取对应的 Integer 并返回，所以 a 和 b 返回的是同一个对象，所以比较是相等的，当赋值 200 给 Integer 时，不在 cache 的范围内，所以会 new Integer 并返回，当然比较的结果是不相等的。

> 扩展：Byte，Short，Integer，Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False

```java
System.out.println(Integer.valueOf(-128) == Integer.valueOf(-128));//1.true
System.out.println(Integer.valueOf(127) == Integer.valueOf(127));//2.true
System.out.println(Integer.valueOf(128) == Integer.valueOf(128));//3.false
System.out.println(Integer.parseInt("128") == Integer.valueOf(128));//4.true
```

1、2、3 都好理解，缓存范围是 [-128，127]，1、2 都在范围内，返回的是缓存中的对象，因此输出 true，3 不在范围内，返回的是新 new 的 Integer，因此输出 false。

那为什么 4 输出的是 true 呢？ 128 在缓存范围外，按道理会 new 出一个 Integer 对象，为什么输出 true 呢？

- 首先 Integer. ParseInt 方法返回的是 int 基本数据类型，不是对象，也就是说 Integer.ParseInt ("128") = 128
  ```java
  public static int parseInt(String s) throws NumberFormatException {
      return parseInt(s,10);
  }
  ```

- 当进行比较 == 运算时，会进行自动拆箱，也就是说 Integer.ValueOf (128) 生成的 Integer 会自动拆箱成 128，那么比较两个相等的额数值自然是 true 的

**注意**：使用 == 运算符时，需要一边是基本数据类型才会自动拆箱，如果两边都是引用数据类型，是不会自动拆箱的。

> 当基础类型与它们的包装类有如下几种情况时，编译器会自动进行装箱或拆箱：
>
> - 赋值操作（装箱或拆箱）
>- 进行加减乘除混合运算 （拆箱）
> - 进行>,<,>=,<=,== 比较运算（拆箱）
>- 调用 equals 进行比较（装箱）
> - ArrayList、HashMap 等集合类添加基础类型数据时（装箱）

注意：三目运算符 condition ? 表达式 1：表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常

1. 表达式 1 或表达式 2 的值只要有一个是原始类型。
2. 表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。

```java
Integer a = 1;
Integer b = 2;
Integer c = null;
Boolean flag = false;
// a*b 的结果是 int 类型，那么 c 会强制拆箱成 int 类型，抛出 NPE 异常
Integer result = (flag ? a * b : c);
```

需要注意的是，如果使用 `new Integer()` 创建对象，即使值在 -128 到 127 范围内，也不会被缓存，每次都会创建新的对象。因此，推荐使用 `Integer.valueOf()` 方法获取整数对象。

缓存机制存在的原因：将频繁被使用的对象缓存起来，可以提升读取的效率，这是一个典型的用空间换时间的例子（其实缓存机制都是这个原理），而 Java 开发者认为[-128，127]是比较常使用的范围。

使用数据类型缓存池可以有效提高程序的性能和节省内存开销，但需要注意的是，在特定的业务场景下，缓存池可能会带来一些问题，例如缓存池中的对象被不同的线程同时修改，导致数据错误等问题。因此，在实际开发中，需要根据具体的业务需求来决定是否使用数据类型缓存池。




## 数组是不是对象

什么是对象？
对象是类的一个实例，有状态和行为  

Java 对象： 

- 软件的对象也有行为和状态 
- 软件对象的状态称之为属性 
- 方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成  

而 java 中的数组具有 java 中其他对象的一些基本特点。比如封装了一些数据，可以访问属性，也可以调用方法。因此，数组是对象



### 证明

可以通过代码验证数组是对象的事实
```java
Class clz = int[].class;
System.out.println(clz.getSuperclass().getName());//java.lang.Object
```

显然，数组继承与 Object，是对象


同理，二维数组也是对象
```java
int[][] arr = new int[2][];
System.out.println(arr.getClass().getSuperclass().getName());//java.lang.Object
```



### 为什么使用 Arrays. Sort 时不能自定义比较器

Arrays.Sort () 默认是升序排序，如果要降序排序，需要自定义比较器
```java
int[] arr = new int[]{1, 2, 3, 4};
Arrays.sort(arr, (a, b) -> Integer.compare(b,a));//报错
```
报错显示：需要的是 int 类型，但提供的是 T 类型的
![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202408031537390.png)

这是因为 `Arrays.sort` 方法有多个重载版本，其中针对基本类型数组（如 `int[]`）的版本不接受自定义比较器。你尝试传入一个自定义比较器给 `int[]` 数组的 `Arrays.sort` 方法，因此会导致编译错误。

具体来说，`Arrays.sort` 有以下几种主要的重载方法：

1. `Arrays.sort(int[] arr)`：用于排序 `int` 数组，按自然顺序排序，不接受比较器。
2. `Arrays.sort(T[] arr, Comparator<? super T> c)`：用于排序泛型对象数组，按自定义比较器排序。

因此如果试图将一个自定义比较器传入 `int` 数组的 `Arrays.sort` 方法，这是不被允许的，因为基本类型数组的排序方法不接受比较器。



一维数组自定义排序可以用如下方法：

```java
arr = Arrays.stream(arr)
                .boxed()
                .sorted((a,b) -> b-a)
                .mapToInt(Integer::intValue)
                .toArray();
```



