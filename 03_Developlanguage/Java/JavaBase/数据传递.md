---
Title: Java 基础核心要点-数据传递
Category: Java
tags:
  - java
  - 数据传递
---
## Java 为什么是值传递？

### 形参&实参

方法的定义可能会用到 **参数**（有参的方法），参数在程序语言中分为：

- **实参（实际参数，Arguments）**：用于传递给函数/方法的参数，必须有确定的值。
- **形参（形式参数，Parameters）**：用于定义函数/方法，接收实参，不需要有确定的值。

```java
String hello = "Hello!";
// hello 为实参
SayHello (hello);
// str 为形参
Void sayHello (String str) {
    System.Out.Println (str);
}
```



### 值传递&引用传递

程序设计语言将实参传递给方法（或函数）的方式分为两种：

- **值传递**：方法接收的是实参值的拷贝，会创建副本。
- **引用传递**：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。

很多程序设计语言（比如 C++、 Pascal ) 提供了两种参数传递的方式，不过，在 Java 中只有值传递。



### 为什么 Java 只有值传递？

**为什么说 Java 只有值传递呢？** 通过 3 个例子来给大家证明。

#### 案例 1：传递基本类型参数

代码：

```java
Public static void main (String[] args) {
    Int num 1 = 10;
    Int num 2 = 20;
    Swap (num 1, num 2);
    System.Out.Println ("num 1 = " + num 1);
    System.Out.Println ("num 2 = " + num 2);
}

Public static void swap (int a, int b) {
    Int temp = a;
    A = b;
    B = temp;
    System.Out.Println ("a = " + a);
    System.Out.Println ("b = " + b);
}
```

输出：

```plain
A = 20
B = 10
Num 1 = 10
Num 2 = 20
```

解析：在 `swap ()` 方法中，`a`、`b` 的值进行交换，并不会影响到 `num 1`、`num 2`。因为，`a`、`b` 的值，只是从 `num 1`、`num 2` 的复制过来的。也就是说，a、b 相当于 `num 1`、`num 2` 的副本，副本的内容无论怎么修改，都不会影响到原件本身。

通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2。



#### 案例 2：传递引用类型参数 1

代码：

```java
  Public static void main (String[] args) {
      Int[] arr = { 1, 2, 3, 4, 5 };
      System.Out.Println (arr[0]);
      Change (arr);
      System.Out.Println (arr[0]);
  }

  Public static void change (int[] array) {
      // 将数组的第一个元素变为 0
      Array[0] = 0;
  }
```

输出：

```plain
1
0
```

看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！

也就是说 `change` 方法的参数拷贝的是 `arr` （实参）的地址，因此，它和 `arr` 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。

为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！

#### 案例 3：传递引用类型参数 2

```java
Public class Person {
    Private String name;
   // 省略构造函数、Getter&Setter 方法
}

Public static void main (String[] args) {
    Person xiaoZhang = new Person ("小张");
    Person xiaoLi = new Person ("小李");
    Swap (xiaoZhang, xiaoLi);
    System.Out.Println ("xiaoZhang: " + xiaoZhang.GetName ());
    System.Out.Println ("xiaoLi: " + xiaoLi.GetName ());
}

Public static void swap (Person person 1, Person person 2) {
    Person temp = person 1;
    Person 1 = person 2;
    Person 2 = temp;
    System.Out.Println ("person 1: " + person 1.GetName ());
    System.Out.Println ("person 2: " + person 2.GetName ());
}
```

输出:

```plain
Person 1: 小李
Person 2: 小张
XiaoZhang: 小张
XiaoLi: 小李
```

解析：`swap` 方法的参数 `person 1` 和 `person 2` 只是拷贝的实参 `xiaoZhang` 和 `xiaoLi` 的地址。因此， `person 1` 和 `person 2` 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 `xiaoZhang` 和 `xiaoLi` 。



### 引用传递是怎么样的？

看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。
但是，引用传递到底长什么样呢？下面以 `C++` 的代码为例，让你看一下引用传递的庐山真面目。

```C++
#include <iostream>

Void incr (int& num)
{
    Std:: cout << "incr before: " << num << "\n";
    Num++;
    Std:: cout << "incr after: " << num << "\n";
}

Int main ()
{
    Int age = 10;
    Std:: cout << "invoke before: " << age << "\n";
    Incr (age);
    Std:: cout << "invoke after: " << age << "\n";
}
```

输出结果：

```plain
Invoke before: 10
Incr before: 10
Incr after: 11
Invoke after: 11
```

分析：可以看到，在 `incr` 函数中对形参的修改，可以影响到实参的值。要注意：这里的 `incr` 形参的数据类型用的是 `int&` 才为引用传递，如果是用 `int` 的话还是值传递哦！



### 为什么 Java 不引入引用传递呢？

引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？

**注意：以下为个人观点看法，并非来自于 Java 官方：**

1. 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。
2. Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。

### 小结

Java 中将实参传递给方法（或函数）的方式是 **值传递**：

- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

