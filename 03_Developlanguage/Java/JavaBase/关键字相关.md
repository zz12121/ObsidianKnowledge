---
Title: Java 基础核心要点-关键字相关
Category: Java
tags:
  - java
  - 关键字
---
## 关键字

### Final

1. 数据：声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

   - 对于基本类型，final 使数值不变；

   - 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

2. 方法：声明方法不能被子类重写。
   - Private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

3. 类：声明类不允许被继承。

### Static

1. 静态变量
   - 静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。
   - 实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。

2. 静态方法

   - 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法 (abstract)。

   - 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。

3. 静态语句块
   - 静态语句块在类初始化时运行一次。

4. 静态内部类

   - 非静态内部类依赖于外部类的实例，而静态内部类不需要。

   - 静态内部类不能访问外部类的非静态的变量和方法。

5. 静态导包
   - 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。

#### 初始化顺序

1. 静态属性，静态代码块。

2. 普通属性，普通代码块。

3. 构造方法。

```java
public class InitOrder {

    // 静态属性
    private static String staticField = getStaticField();

    // 静态代码块
    static {
        System.out.println(staticField);
        System.out.println("静态代码块初始化");
    }

    // 普通属性
    private String field = getField();

    // 普通代码块
    {
        System.out.println(field);
        System.out.println("普通代码块初始化");
    }

    // 构造方法
    public InitOrder() {
        System.out.println("构造方法初始化");
    }

    // 静态方法
    public static String getStaticField() {
        String staticFiled = "静态属性初始化";
        return staticFiled;
    }

    // 普通方法
    public String getField() {
        String filed = "普通属性初始化";
        return filed;
    }

    public static void main(String[] argc) {
        new InitOrder();
    }

    /**
     *      静态属性初始化
     *      静态代码块初始化
     *      普通属性初始化
     *      普通代码块初始化
     *      构造方法初始化
     */
}
```



#### 静态方法和变量能否被继承

能

父类 A：

```java
public class A {
    public static String staticStr = "A静态属性";
    public String nonStaticStr = "A非静态属性";
    public static void staticMethod(){
        System.out.println("A静态方法");
    }
    public void nonStaticMethod(){
        System.out.println("A非静态方法");
    }
}
```



子类 B：

```java
public class B extends A{

    public static String staticStr = "B改写后的静态属性";
    public String nonStaticStr = "B改写后的非静态属性";

    public static void staticMethod(){
        System.out.println("B改写后的静态方法");
    }

    @Override
    public void nonStaticMethod() {
        System.out.println("B改写后的非静态方法");
    }
}
```



子类 C：

```java
Public class C extends A{
}
```



测试：

```java
Public class Demo {
    Public static void main (String[] args) {
        C c = new C ();//C 的引用指向 C 的对象
        System.Out.Println (c.nonStaticStr);//A 非静态属性
        System.Out.Println (c.staticStr);//A 静态属性
        c.nonStaticMethod ();//A 非静态方法
        c.staticMethod ();//A 静态方法
        //推出静态属性和静态方法可以被继承

        System.Out.Println ("-------------------------------");

        A c 1 = new C ();//A 的引用指向 C 的对象
        System.Out.Println (c 1. NonStaticStr);//A 非静态属性
        System.Out.Println (c 1. StaticStr);//A 静态属性
        C 1.NonStaticMethod ();//A 非静态方法
        C 1.StaticMethod ();//A 静态方法
        //推出静态属性和静态方法可以被继承

        System.Out.Println ("-------------------------------");
        B b = new B ();//B 的引用指向 B 的对象
        System.Out.Println (b.nonStaticStr);//B 改写后的非静态属性
        System.Out.Println (b.staticStr);//B 改写后的静态属性
        b.nonStaticMethod ();//B 改写后的非静态方法
        b.staticMethod ();//B 改写后的静态方法

        System.Out.Println ("-------------------------------");
        A b 1 = new B ();//A 的引用指向 B 的对象
        System.Out.Println (b 1. NonStaticStr);//A 非静态属性
        System.Out.Println (b 1. StaticStr);//A 静态属性
        B 1.NonStaticMethod ();//B 改写后的非静态方法
        B 1.StaticMethod ();//A 静态方法
        //结果都是父类的静态方法，说明静态方法不可以被重写，不能实现多态
    }
}
```



#### Static 小结

- 子类会继承父类的静态方法和静态变量，但是无法对静态方法进行重写

- 子类中可以直接调用父类的静态方法和静态变量

- 子类可以直接修改（如果父类中没有将静态变量设为 private）静态变量，但这是子类自己的静态变量。

- 子类可以拥有和父类同名的，同参数的静态方法，但是这并不是对父类静态方法的重写，是子类自己的静态方法，子类只是把父类的静态方法隐藏了。

- 当父类的引用指向子类时，使用对象调用静态方法或者静态变量，是调用的父类中的静态方法或者变量（这比较好理解，因为静态方法或变量是属于类的，而引用指向的是一个对象，对象中并不会包含静态的方法和属性）。**也就是说，失去了多态。**

- 当子类的引用指向子类时，使用对象调用静态方法或者静态变量，就是调用的子类中自己的的静态方法或者变量了。



#### 注意

静态变量尤其要注意并发问题。因为静态变量在 Java 中是类级别的变量，它们被所有类的实例共享。由于静态变量是共享资源，当多个线程同时访问和修改静态变量时，就会引发并发问题。



###  transient

Java 语言的关键字，变量修饰符，如果用 transient 声明一个实例变量，当对象存储时，它的值不需要维持。

也就是说被 transient 修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
