---
Title: Java 面向对象-重载和重写
Category: Java
tags:
  - java
  - 面向对象
---
如果一个类有多个名字相同但参数个数不同的方法，我们通常称这些方法为方法重载。 如果方法的功能是一样的，但参数不同，使用相同的名字可以提高程序的可读性。  
  
如果子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），我们称之为方法重写。 方法重写用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。  
  
只不过，方法重载与方法重写在名字上很相似，就像是兄弟俩，方法重载的英文名叫 Overloading，方法重写的英文名叫 Overriding，因此，不仅中文名很相近，英文名之间也很相近，这就更容易让初学者搞混了。  
  
但两者其实是完全不同的！  
  
### 01、方法重载  
  
在 Java 中，有两种方式可以达到方法重载的目的。  
  
第一，改变参数的数目。来看下面这段代码。  
  
```java  
public class OverloadingByParamNum {
    public static void main(String[] args) {
        System.out.println(Adder.add(10, 19));
        System.out.println(Adder.add(10, 19, 20));
    }
}

class Adder {
    static int add(int a, int b) {
        return a + b;
    }

    static int add(int a, int b, int c) {
        return a + b + c;
    }
}   
```  
  
Adder 类有两个方法，第一个 `add()` 方法有两个参数，在调用的时候可以传递两个参数；第二个 `add()` 方法有三个参数，在调用的时候可以传递三个参数。  
  
这样的代码不会显得啰嗦吗？如果有四个参数的时候就再追加一个方法？  
  
这个例子只是为了说明方法重载的一种类型。如果参数类型相同的话，Java 提供了可变参数的方式，就像下面这样。  
  
```java  
static int add(int ... args) {
    int sum = 0;
    for ( int a: args) {
        sum += a;
    }
    return sum;
}
```  
  
第二，通过改变参数类型，也可以达到方法重载的目的。来看下面这段代码。
  
```java  
public class OverloadingByParamType {
    public static void main(String[] args) {
        System.out.println(Adder.add(10, 19));
        System.out.println(Adder.add(10.1, 19.2));
    }
}

class Adder {
    static int add(int a, int b) {
        return a + b;
    }

    static double add(double a, double b) {
        return a + b;
    }
}
```  
  
Adder 类有两个方法，第一个 `add()` 方法的参数类型为 int，第二个 `add()` 方法的参数类型为 double。  
  
改变参数的数目和类型都可以实现方法重载，为什么改变方法的返回值类型就不可以呢？  
  
因为仅仅改变返回值类型的话，会把编译器搞懵逼的。  
  
编译时报错优于运行时报错，所以当两个方法的名字相同，参数个数和类型也相同的时候，虽然返回值类型不同，但依然会提示方法已经被定义的错误。  
  
我们在调用一个方法的时候，可以指定返回值类型，也可以不指定。当不指定的时候，直接指定 `add(1, 2)` 的时候，编译器就不知道该调用返回 int 的 `add()` 方法还是返回 double 的 `add()` 方法，产生了歧义。  
  
方法的返回值只是作为方法运行后的一个状态，它是保持方法的调用者和被调用者进行通信的一个纽带，但并不能作为某个方法的‘标识’。  
  
`main()` 方法可以重载吗？  
  
答案是肯定的，毕竟 `main()` 方法也是个方法，只不过，Java 虚拟机在运行的时候只会调用带有 String 数组的那个 `main()` 方法。  
  
```java  
public class OverloadingMain {
    public static void main(String[] args) {
        System.out.println("String[] args");
    }

    public static void main(String args) {
        System.out.println("String args");
    }

    public static void main() {
        System.out.println("无参");
    }
}
```  
  
第一个 `main()` 方法的参数形式为 `String[] args`，是最标准的写法；第二个 `main()` 方法的参数形式为 `String args`，少了中括号；第三个 `main()` 方法没有参数。  
  
来看一下程序的输出结果。 
  
```  
String[] args  
```  
  
从结果中，我们可以看得出，尽管 `main()` 方法可以重载，但程序只认标准写法。  
  
由于可以通过改变参数类型的方式实现方法重载，那么当传递的参数没有找到匹配的方法时，就会发生隐式的类型转换。    

![[09_Attachments/Java/JavaBase/05_面向对象/Java_05_012.png]]

如上图所示，byte 可以向上转换为 short、int、long、float 和 double，short 可以向上转换为 int、long、float 和 double，char 可以向上转换为 int、long、float 和 double，依次类推。  
  
```java  
public class OverloadingTypePromotion {
    void sum(int a, long b) {
        System.out.println(a + b);
    }

    void sum(int a, int b, int c) {
        System.out.println(a + b + c);
    }

    public static void main(String args[]) {
        OverloadingTypePromotion obj = new OverloadingTypePromotion();
        obj.sum(20, 20);
        obj.sum(20, 20, 20);
    }
}
```  
  
执行 `obj.sum(20, 20)` 的时候，发现没有 `sum(int a, int b)` 的方法，所以此时第二个 20 向上转型为 long，所以调用的是 `sum(int a, long b)` 的方法。  
  
再来看一个示例。  
  
```java  
public class OverloadingTypePromotion1 {
    void sum(int a, int b) {
        System.out.println("int");
    }

    void sum(long a, long b) {
        System.out.println("long");
    }

    public static void main(String args[]) {
        OverloadingTypePromotion1 obj = new OverloadingTypePromotion1();
        obj.sum(20, 20);
    }
}
```  
  
执行 `obj.sum(20, 20)` 的时候，发现有 `sum(int a, int b)` 的方法，所以就不会向上转型为 long。  
  
来看一下程序的输出结果。  
  
```  
int  
```  
  
继续来看示例。  
  
```java  
public class OverloadingTypePromotion2 {
    void sum(long a, int b) {
        System.out.println("long int");
    }

    void sum(int a, long b) {
        System.out.println("int long");
    }

    public static void main(String args[]) {
        OverloadingTypePromotion2 obj = new OverloadingTypePromotion2();
        obj.sum(20, 20);
    }
}
```  
  
当有两个方法 `sum(long a, int b)` 和 `sum(int a, long b)`，参数个数相同，参数类型相同，只不过位置不同的时候，会发生什么呢？”  
  
当通过 `obj.sum(20, 20)` 来调用 sum 方法的时候，编译器会提示错误。    
  
不明确，编译器会很为难，究竟是把第一个 20 从 int 转成 long 呢，还是把第二个 20 从 int 转成 long，智障了！所以，不能写这样让编译器左右为难的代码。  
  
### 02、方法重写  
  
在 Java 中，方法重写需要满足以下三个规则。  
  
- 重写的方法必须和父类中的方法有着相同的名字；  
- 重写的方法必须和父类中的方法有着相同的参数；  
- 必须是 is-a 的关系（继承关系）。  
  
来看下面这段代码。  
  
```java  
public class Bike extends Vehicle {
    public static void main(String[] args) {
        Bike bike = new Bike();
        bike.run();
    }
}

class Vehicle {
    void run() {
        System.out.println("车辆在跑");
    }
}
```  
  
来看一下程序的输出结果。  
  
```  
车辆在跑  
```  
  
Bike is-a Vehicle，自行车是一种车，没错。Vehicle 类有一个 `run()` 的方法，也就是说车辆可以跑，Bike 继承了 Vehicle，也可以跑。但如果 Bike 没有重写 `run()` 方法的话，自行车就只能是‘车辆在跑’，而不是‘自行车在跑’，对吧？  
  
如果有了方法重写，一切就好办了。  
  
```java  
public class Bike extends Vehicle {
    @Override
    void run() {
        System.out.println("自行车在跑");
    }

    public static void main(String[] args) {
        Bike bike = new Bike();
        bike.run();
    }
}

class Vehicle {
    void run() {
        System.out.println("车辆在跑");
    }
}
```  
  
Bike 类的 `run()` 方法，在方法重写的时候，IDEA 会建议使用 `@Override` 注解，显式的表示这是一个重写后的方法，尽管可以缺省。  
  
来看一下程序的输出结果。  
  
```  
自行车在跑  
```  
  
Bike 重写了 `run()` 方法，也就意味着，Bike 可以跑出自己的风格。  
  
好，接下来说一下重写时应当遵守的 12 条规则，应当谨记哦。  
  
#### **规则一：只能重写继承过来的方法**。  
  
因为重写是在子类重新实现从父类继承过来的方法时发生的，所以只能重写继承过来的方法，这很好理解。这就意味着，只能重写那些被 public、protected 或者 default 修饰的方法，private 修饰的方法无法被重写。  
  
Animal 类有 `move()`、`eat()` 和 `sleep()` 三个方法：  
  
```java  
public class Animal {
    public void move() { }

    protected void eat() { }
    
    void sleep(){ }
}
```  
  
Dog 类来重写这三个方法：  
  
```java  
public class Dog extends Animal {
    public void move() { }

    protected void eat() { }

    void sleep(){ }
}
```  
  
OK，完全没有问题。但如果父类中的方法是 private 的，就行不通了。  
  
```java  
public class Animal {  
    private void move() { }
}  
```  
  
此时，Dog 类中的 `move()` 方法就不再是一个重写方法了，因为父类的 `move()` 方法是 private 的，对子类并不可见。  
  
```java  
public class Dog extends Animal {  
    public void move() { }
}  
```  
  
#### **规则二：final、static 的方法不能被重写**。  
  
一个方法是 [Final](03_Developlanguage/Java/JavaBase/02_关键字/Final.md) 的就意味着它无法被子类继承到，所以就没办法重写。  
  
```java  
public class Animal {  
    final void move() { }
}  
```  
  
由于父类 Animal 中的 `move()` 是 final 的，所以子类在尝试重写该方法的时候就出现编译错误了！    
  
同样的，如果一个方法是 [Static](03_Developlanguage/Java/JavaBase/02_关键字/Static.md) 的，也不允许重写，因为静态方法可用于父类以及子类的所有实例。  
  
```java  
public class Animal {  
    static void move() { }
}  
```  
  
重写的目的在于根据对象的类型不同而表现出多态，而静态方法不需要创建对象就可以使用。没有了对象，重写所需要的“对象的类型”也就没有存在的意义了。    
  
#### **规则三：重写的方法必须有相同的参数列表**。  
  
```java  
public class Animal {  
    void eat(String food) { }
}  
```  
  
Dog 类中的 `eat()` 方法保持了父类方法 `eat()` 的同一个调调，都有一个参数——String 类型的 food。  
  
```java  
public class Dog extends Animal {  
    public void eat(String food) { }
}  
```  
  
一旦子类没有按照这个规则来，比如说增加了一个参数：  
  
```java  
public class Dog extends Animal {  
    public void eat(String food, int amount) { }
}  
```  
  
这就不再是重写的范畴了，当然也不是重载的范畴，因为重载考虑的是同一个类。  
  
**规则四：重写的方法必须返回相同的类型**。  
  
父类没有返回类型：  
  
```java  
public class Animal {  
    void eat(String food) { }
}  
```  
  
子类尝试返回 String：  
  
```java  
public class Dog extends Animal {  
    public String eat(String food) {        
    return null;    
    }
}  
```  
  
于是就编译出错了（返回类型不兼容）。    
  
#### **规则五：重写的方法不能使用限制等级更严格的权限修饰符**。  
  
可以这样来理解：  
  
- 如果被重写的方法是 default，那么重写的方法可以是 default、protected 或者 public。  
- 如果被重写的方法是 protected，那么重写的方法只能是 protected 或者 public。  
- 如果被重写的方法是 public， 那么重写的方法就只能是 public。  
  
举个例子，父类中的方法是 protected：  
  
```java  
public class Animal {  
    protected void eat() { }
}  
```  
  
子类中的方法可以是 public：  
  
```java  
public class Dog extends Animal {  
    public void eat() { }
}  
```  
  
如果子类中的方法用了更严格的权限修饰符，编译器就报错了。    
  
#### **规则六：重写后的方法不能抛出比父类中更高级别的异常**。  
  
举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是 IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。  
  
可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要求。  
  
父类抛出 IOException：  
  
```java  
public class Animal {  
    protected void eat() throws IOException { }
}  
```  
  
子类抛出 FileNotFoundException 是可以满足重写的规则的，因为 FileNotFoundException 是 IOException 的子类。  
  
```java  
public class Dog extends Animal {  
   public void eat() throws FileNotFoundException { }
}  
```  
  
如果子类抛出了一个新的异常，并且是一个 checked 异常：  
  
```java  
public class Dog extends Animal {  
   public void eat() throws FileNotFoundException, InterruptedException { }
}  
```  
  
那编译器就会提示错误：  
  
```  
Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖com.itwanger.overriding.Animal中的eat()  
  被覆盖的方法未抛出java.lang.InterruptedException  
```  
  
但如果子类抛出的是一个 unchecked 异常，那就没有冲突：  
  
```java  
public class Dog extends Animal {  
   public void eat() throws FileNotFoundException, IllegalArgumentException { }
}  
```  
  
如果子类抛出的是一个更高级别的异常：  
  
```java  
public class Dog extends Animal {  
   public void eat() throws Exception { }
}  
```  
  
编译器同样会提示错误，因为 Exception 是 IOException 的父类。  
  
```  
Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖com.itwanger.overriding.Animal中的eat()  
  被覆盖的方法未抛出java.lang.Exception  
```  
  
#### **规则七：可以在子类中通过 super 关键字来调用父类中被重写的方法**。  
  
子类继承父类的方法而不是重新实现是很常见的一种做法，在这种情况下，可以按照下面的形式调用父类的方法：  
  
```java  
super.overriddenMethodName();  
```  
  
来看例子。  
  
```java  
public class Animal {  
    protected void eat() { }
}  
```  
  
子类重写了 `eat()` 方法，然后在子类的 `eat()` 方法中，可以在方法体的第一行通过 `super.eat()` 调用父类的方法，然后再增加属于自己的代码。  
  
```java  
public class Dog extends Animal {  
   public void eat() {       
   super.eat();       // Dog-eat   
   }
}  
```  
  
#### **规则八：构造方法不能被重写**。  
  
因为构造方法很特殊，而且子类的构造方法不能和父类的构造方法同名（类名不同），所以构造方法和重写之间没有任何关系。  
  
#### **规则九：如果一个类继承了抽象类，抽象类中的抽象方法必须在子类中被重写**。  
  
先来看这样一个接口：  
  
```java  
public interface Animal {  
    void move();
}  
```  
  
接口中的方法默认都是抽象方法，通过反编译是可以看得到的：  
  
```java  
public interface Animal  
{  
    public abstract void move();
}  
```  
  
如果一个抽象类实现了 Animal 接口，`move()` 方法不是必须被重写的：  
  
```java  
public abstract class AbstractDog implements Animal {  
    protected abstract void bark();
}  
```  
  
但如果一个类继承了抽象类 AbstractDog，那么 Animal 接口中的 `move()` 方法和抽象类 AbstractDog 中的抽象方法 `bark()` 都必须被重写：  
  
```java  
public class BullDog extends AbstractDog {  
     public void move() {}  
     protected void bark() {}  
}  
```  
  
#### **规则十：synchronized 关键字对重写规则没有任何影响**。  
  
synchronized 关键字用于在多线程环境中获取和释放监听对象，因此它对重写规则没有任何影响，这就意味着 synchronized 方法可以去重写一个非同步方法。  
  
#### **规则十一：strictfp 关键字对重写规则没有任何影响**。  
  
如果你想让浮点运算更加精确，而且不会因为硬件平台的不同导致执行的结果不一致的话，可以在方法上添加 strictfp 关键字，之前讲过。因此 strictfp 关键字和重写规则无关。  
  
### 03、总结  
  
首先来说一下方法重载时的注意事项，‘两同一不同’。  
  
‘两同’：在同一个类，方法名相同。  
  
‘一不同’：参数不同。  
  
再来说一下方法重写时的注意事项，‘两同一小一大’。  
  
‘两同’：方法名相同，参数相同。  
  
‘一小’：子类方法声明的异常类型要比父类小一些或者相等。  
  
‘一大’：子类方法的访问权限应该比父类的更大或者相等。  
